/*
* 10진수 2진수 16진수 익숙하게..
* 
* 기억 클래스 / 속성 수식자 / 부호 / 크기 수식자 / 기본자료형
* 
* extern: 외부 어딘가에 해당 전역변수가 있다. 링크할때 찾아라.
* 
* a.cpp
*    int g_a;
*    void test(){}
* 
* b.cpp
*    int g_a; -> 링크에러
*	 void a(){test()}
* 
* **********************************************************
* 링크: b.cpp 입장에서는 test모름. 그래서 에러. 그래서 선언부에 선언해줌(이런함수가 존재한다 알려준다.). 있겠지 -> pass -> 아직 주소 안나옴. -> 이후 실제 테스트를 알게되면
* 해당 주소를 넣어줌.
* 
* 같은 함수.. -> 링크에러 ->
* 
* 컴파일에러: 문법 문제
* 링크에러: 관계 문제
* 
* 컴파일타임에 치환: auto
* 
* 지역 스태틱 static int x:
* -> 값이 보존된다. 초기화가 한번만 된다. -> 데이터영역. 전역변수인데 해당 함수로 제한접근.
* 
* 전역 스태틱 static int g_x = 0; -> 해당 cpp에서만 사용하는 전역. a.cpp b.cpp에 만들면 cpp단위로 만들어진다. 
* -> 다른 cpp에서 못 건드리게..
* -> 실수로 건드려도 따로 만듬..
* 
* volatile: 해당 변수의 로직을 최적화 컴파일하지마라.
* -> 최적화 컴파일은 멀티스레드를 예상 안함. 
* -> 최적화 컴파일은 로직 순서까지도 바꿈.
* -> 인라인처리는 해버리는 경우도 있다. <- 컴파일러마다 다름.
* -> 언제쓰냐?? 최적화 컴파일 상태면 -> volatile로 하나씩. 
* 
* 캐시: 최신 데이터.
* 램: 과거 데이터.
* 
* const: 상수화. 실제 메모리 ro가 아니다.
* 
* casting: 강제로 해라. 문법상 에러 내지마라.
* 정수->실수, 실수->정수: 이 경우는 제외. 데이터 사용이달라서.. 함수call
* 
* 64bit 데이터 모델.
* 
* llp64
* 
* ***************************************
* unity(c#) long-> 8byte
* ***************************************
* 
* 데이터 타입: 
  
  네트워크 프로토콜일때 데이터 타입을 줄이는건 굉장히 중요하다.. -> 네트워크 트래픽.
  스플라 라이센스. 대당 2만원선.

* ******************************************************************************************
* 변수 선언, 초기화
* 선언과 동시 초기화.
* int a = 0;
* 선언하고 이후 초기화.
* int b;
* b = 0;
* a++;
* b++;
* ************************************************둘은 차이가 없다.
* 클래스는 다르다. 해당 자리에서 생성자를 호출한다.
* 
* (* / % + - 보다 나중에 해야된다. -> >> <<: 쉬프트).
* 
* 
* 
*/

#include <stdio.h>

int main()
{
	// ro 아님. 런타임인데, 이번 경우는 컴파일러가 컴파일타임에 10 박음. 
	const int a = 10;

	// 권장: 상수화. 
	//constexpr

	// sizeof=> 상수로 치환.
	int* p = (int* )&a;

	*p = 20;

	printf("%d", a);

	/*
	* 실제 메모리 a 바꼈지만, 컴파일러가 그냥 10을 박아서.... 
	  컴파일 순간 a를 확정 10(리터럴 상수)하고 그것을 printf에 넣은 것.
	*/


	return 0;
}