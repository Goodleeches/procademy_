/*
* 함수호출 ret:
* eax
* 
* 함수 호출규약:
* __cdecl: 
* __stdcall: ret에 인자.. 인자 수치만큼 돌아가서 땡긴다.
* 
* __fastcall: 레지스터도 이용한다. ==> 64비트는 __cdecl __stdcall도 레지스터 이용.
* 
* 레지스터 내 매개변수, 스택 위 매개변수 순서, 스택 정리 주체.
* 
* 스택 정리 주체: 스택 프레임을 정리해주는게 아니라(이건 언제나 자기 자신).. => 파라미터에 해당하는 스택을 말한다. 파라미터 4 4 4 = 12인데 이거 누가 정리할까를 말하는 것. 
* 
* __cedcl:
* 장점: 1. 명확한 장점 한가지 호출자가 파라미터 크기를 알수 있다. (파라미터가 정해졌을 때 말고.. printf처럼 가변인자..를 사용할 때)
		   가변인자 구조는 무조건  cdecl만 가능하다.
		
* 단점: 스택정리 어셈코드가 추가로 무조건 들어간다.
* 
* 현재 c++은 __cedcl을 기본으로
* winapi는 __stdcall
* 
* __stdcall:
* 장점: 어셈블리코드 양이 줄어든다. 연산 자체가 줄어든다는 아님.
* 단점: 장점같지 않은 장점. 가변인자 사용 못함.
* 
*/

///////////////////////////////////////////////////////////
// 
// 상수전달은 문제가 없다 하지만,
// 아래와 같은 경우 매개변수 순서가 영향.
// 
// 
///////////////////////////////////////////////////////////
int g_x = 0;

int X()
{
	g_x++;

	return g_x;
}

void Test(int a, int b, int c)
{
	// 외부 값을 파라미터로 지역 스택프레임으로 받아오면, ebp+8 아래쪽 스택에 접근해서
	// 그걸 가져옴..
	a++;
	b++;
	c++;
}

int main()
{
	//////////////////////////////////////////////////////////
	//
	// stdcall로 만들어진 함수를 cdecl콜로 생각하고 호출한다면 2번 스택프레임이 정리된다(파라미터에 대한).
	//
	// esp는 최상단에 있어야한다. 하지만 2번내려가면, 지역공간으로 활용된 공간도 안쓰는 공간처럼 되어버림.
	// 
	// 문제가 되는 경우:
	// 1. Push를 하는 경우. 함수호출을 한다던가. 기존 esp부터 Push해버리니까 지역변수가 오염된다.
	// 
	// 2. 스택 정리할때... 문제가 될 수 있다.
	//    1. ebp를 esp에 넣어주는 경우 문제없음.
	//	  2. esp에 값을 직접 넣어주는 경우 문제. (이때 스택프레임 다 밀림)
	// 
	// 
	// 정의 선언 다르면 에러: 사실 스택 두번 내려갈일 생길 일은 없음.
	// 
	// 호출부에 따라서 우리 함수를 만들어야 하는 경우: 콜백(코드는 우리가 짠다. 호출은 Windowapi가 호출한다. 비동기i/o)
	// 함수포인터를 등록시켜야 한다.
	// 비동기: 호출은 지금하지만 결과 실행 나중에.
	// 
	//////////////////////////////////////////////////////////
	Test(X(), X(), X());

	return 0;
}

/*
* 디버그 빌드에서 함수 호출. (증분링크)
* 
* call -> jmp 테이블 -> 실제 함수.
* 
* 디버그 빌드에서 기본으로 증분링크 기능이 활성화가 되어 있다.
* 
* 링크 시간을 단축 시키기 위해.
* 
* 중요 점프 테이블은 상단에 위치해야 한다. 그래야 안밀리니까.
* 
* 디버그에서 왜 스택 프레임을 크게 잡을까?
* 
* 1. 증분링크가 활성화되면 기능 하나가 더 켜짐.
*	 디버깅 도중에 실시간으로 코드 수정 가능. 이게 가능하려면, 스택이 이미 잡혀 있어야한다. 그래서 확보를 크게 한 것이다.
* 
*/

/*
***호출과 리턴의 관계***
* 
* ret로 리턴을 하는데, 리턴은 어떻게 작동하는 거냐.
* 어떻게 돌아가는 걸까?
* 
* 호출한 다음 주소를 기억해야한다.
* 한번의 호출과 리턴이면 레지스터 써도 괜찮을 거 같다. 근데 연속호출이면...
* 그래서 스택프레임에 Push
* 
* call: 이 명령의 다음 명령 주소를 스택 프레임에 넣으면서 점프할게요. 
* ret: 팝하고 해당 주소로 점프할게요.
* 
* 이상한 문제가 생겼을 때 원인 파악.
* 
*/

void Test()
{
	int a = 10;
}

int main()
{
	int a = 0;
	Test();
	a = 1;
	Test();
	a = 2;
	Test();
	a = 3;
	Test();
	a = 4;
	Test();
	a = 5;
	Test();
	a = 6;
	Test();
	a = 7;
	Test();
	return 0;
}

/*
* depth = 2^n
* 안전한 데이터 수는?
* 32번 들어가면 2^32
* 
* 페인트 붓기.
* 
*/