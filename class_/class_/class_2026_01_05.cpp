/*
* 어셈블리의 독해가 목표.
* 
* 어셈블리 강좌를 찾아볼 필요는 없다.
* 
* 레지스터 CPU에 전달할때 레지스터로. 이름이 고정된 변수들.
* 
* 변수를 CPU로 가져와서 연산한다. 
* 
* int a = 0;
* a = a + 1; ram -> eax
*			 -> eax + 1 -> ram
* 
* 이유: 연산장치가 CPU에 있다. 연산을 CPU에서 밖에 못해서. (수리센터)
* 
* 기계어 -> 명령어.
* 
* 어셈블리 -> 문자 명령어로 치환.
* 
* 어셈블리 == 기계어 동급.
*
* [      rax    ][     eax    ]
* [      eax    ]
* [     ][  ax  ]
* [     [ah][al]]
* 
* ebp, esp: 용도 고정. 용도를 고정해서 사용해야한다.
* ebp: 지금 사용하는 스택 프레임 안에서의 밑바닥.
* esp: 스택 포인터.
* 
* 스택메모리: 1MB.
* 
* esp: 자료구조에서 top의 역활.
* 
* cpu 입장에서는 A()라는 함수의 공간. main()이라는 함수의 공간에 대해 모른다.
* 
* 언어 입장에서는 for문 while문은 반복문이 아니다. 반복 로직.
* rep loop: 어셈블리에서의 반복문.
* 
* esi, edi: src의 포인터 dest의 포인터를 넣어줌.
* 
* 공간을 확보하는지에 대해 걸리는 시간이 더 느냐.
* 지역변수 메모리 할당에 대한 착각.
* 지역변수는 메모리를 확보라고 하는 것이 더 어울림.
* 1MB라는 메모리가 이미 있는 것.
* 크기를 얼마나 크게 잡던지, 성능차이가 없다. -> 빼는 크기의 차이.
* 
* 어셈블리는 모든게 포인터.
* 
* 파일 단위 -> 함수 단위.
* 
* 메모리 공간 안에서 함수의 위치가.. 같은 함수여도 esp위치 다름. 언제 호출되냐에 따라서.
* 
* 전역변수 int a를 ++ 시켜서 확인. 껏다켜도.. 명령어에 박힘: [절대주소] **************** 확인 실제 명령어에 주소 값이 들어가 있다 ****************
* 지역변수 맨날 위치바뀜 -> 스택프레임 안에서 논다. 안에서 몇번째. 스택프레임 안에서는 정해져 있음. 스택프레임 시작 기준에서 어디다: [상대주소]
* 스택: 스레드마다 하나씩.
* 
* 메모리구조 -> 근데 이론적으로는 이렇게.
* 윈도우의 랜덤어드레스 기능: 랜덤하게 스택메모리 잡히게.. 실제 메모리 구조가 코드 데이터 힙 스택 이렇지가 않음. 멀티스레드 때문에 스택 여러 개 잡히고 위치도 막 잡히고..
* 
* ***
* PUSH: 현재 esp를 기준으로 값을 넣어준다. 넣어주고 esp 올라간다. [*실제 작동은 빼기해주고 넣는것임*]
* POP: [reg]: 뽑아주고 reg에 넣고 esp 내려간다.
* 
* mov: 뒷 값을 앞에 넣는다. [reg]에, 값  /// [메모리 번지]에, 값
* 
* push: 아래와 같다.
* sub esp, 4
* mov [esp], 10
* 
* mov esp, 10 -> esp 레지스터에 10
* mov [esp], 10 -> esp번지에 10
* []는 역참조 연산.
* 
* pdb
* 
* 릴리즈:기본 최대 최적화. -> 코드를 컴파일러가 자기 멋대로.. 최적화 없애고 뒤집고. 기본으로 inline을 다함.
* 그래서 내 소스코드와 매핑이 안됨.
* 
* 릴리즈 + 최적화 컴파일 끄기..
* 
* cpu 아키텍쳐 -> amd64, x86.
* x86아키텍쳐의 64비트 버전.
* 
* cpu 아키텍쳐는 뭘 뜻하냐? -> 명령어세트, 레지스터세 를 세트로 맞춘 것이 아키텍쳐 ***************** 
* 같은 x86이면 같은 프로그램 돌아감.
* 
* 
*/

