/*
* 전역변수 - 데이터 영역
* 
* 지역변수처럼 mov 로직이 만들어져야하는데,,, 그건 별로니까 아래처럼 ->
* 0 이 아닌 전역변수는 초기화 단계에서 이미지를 떠 버림. 실행파일에 해당 공간을 만들어 넣어둠.
* 
* .ro   -> 읽기 전용. -> 속성이 페이지 단위.
* .data -> 초기화를 한 애들. -> 실제로 올림.
* .bss  -> 초기화를 하지 않은 애들. -> 용량만 기록.
* 
* 2의 보수(자릿수 올림에 필요한 수) -> 반전 시키고 1 더함.
* 9 면 1
* 4 면 6
* 컴퓨터는 빼기 못함. 무조건 더하기.
* 
* 8 - 2 = 8 + 8 = 16하고 10자리 수 지움. -> 6
* 9 - 4 = 9 + 6 = 15 -> 5
* 
* 더하기 연산했을 때 빼기 효과가 나오는 보수로 만들고 그냥 더하는 것임.
* 
* -1 = 0000 0001 -> 1111 1110 -> 1111 1111 << +1 에 대한 2의 보수.
* 
* char a = -1;
* unsigned char b = 255;
* 
* 둘다 0xff
* 보수니까 -1의 효과.
* 
* char x = 1;
* char y = -1;
* 
* 1 + -1 = 0;
* 
* -1을 넣으면 보수화해서 데이터에 넣음.
* 
* 데이터는 데이터고 뭐로 바라보냐의 차이.
* 
* char x = 0xff; => -1
* unsigned y = 0xff => 255
* 
* char a = 0xc9;
* 
* char a = 0xc9
* unsiged a = 0xc9
* 
* 둘다 같다.  a = -55, a = 201
* 음수를 썼지만 2의 보수화 된 수가 들어가 있음.
* 
* 비트 연산.
* 
* 
*/

int g_Array1[1000];
int g_Array2[1000] = {1, 2, 3, 4, 5 };

int g_x1;
int g_x2 = 99;

int main()
{
	// mov로 코드로 초기화 함.
	int x = 10;

	/*
	* 기본타입에 대한 연산
	* 전위 후위 같음.
	*/
	int a = 0;
	++a;
	a++;

	/*
	* 기본 타입은 컴파일러가 알아서 더 적절하게 만들어줘서 차이없음.
	* 사본 안나옴. 하지만 객체면 사본 나올수밖에 없음. 확연히 다름.
	*/
	int b = 0;
	b = ++a;
	b = a++;

	return 0;
}

// 비트연산 대상은 unsigned로 
// signed는 윗 비트가 1로

/*
* unsigned a = 0011 1010
* unsigned char mask = 0000 1111
* a & 0x0f
* a & 0xf0
*
* 원본 xor key => 이상한
* 이상한 xor key => 원본
*
* 바탕화면
* 사각틀 xor
* 이상함
*
* 이상함
* 사각틀 xor
* 바탕화면
*
* 1. 8비트 for문 돌면서 자리마다 비트연산
* 
* 2. 16비트 원하는 위치 비트만 껏다 켰다.
* 
* 3. 8비트 단위로 4바이트 변수를 수정.
* 
* %x: 16진수로
* %p: 포인터주소로
* 
* 질문: 장단점은 나와줘야한다. -> 장단이 비슷하다.
* 
* *************************
* 레지스터: 버퍼, 그릇
* 연산하려면 내부로 가져와야한다.
* eax에서 계산하는게 아님.
* 실제 연산버퍼로 쓰는것도 아님.
* 다시 안으로 끌어가서 연산함.
* 
* fetch -> decode -> excute
* *************************
* 
* // 삼항 연산
* // 한번 확인해보기..
* 
* cmp는 빼기 그리고 제로 플래그
* 
* 제어문.
* if else.
* switch case
* 
* xor eax eax는 해당 레지스터를 0으로 만들때 
* 
* if a && b && c => jne
* if a || b || c => je
* 
* x / y
* 
* 
*/

int main()
{

	return 0;
}